
set -e
# CAVEAT:
#
# This orchestration script is being overhauled to use containerisation
#
# PREPARE:
## clone this repo as the top-level dir, as it will clone the model generation into a subdir
# cd <writeable path> && git clone <url> 
# manually verify that 'modelgen' is in .gitignore , as this is the default path to the model generation repo

# USAGE:
# launch server, verify running from cli, and launch browser to interact:
# $0
# launch server only:
# $0 launch
#
# verify only, useful during development (if server already running):
# $0 verify
#
# browser only, useful during development (if server already running):
# $0 browser

# FUNCTIONALITY
# setup.sh prepares the env by symlinking to files required by the model generation code so the server can accept user input, pass to modelgen, return to user. 
# 
# preparation phase
# implement symlinks for communication between server and modelgen ("pseudo IPC")
#
# build phase
# build "mono-image" containing server code, model generation/management code, and the pseudo-IPC symlinks+files
#
# launch phase
# run the server container as a daemon, record the container name
#
# verify phase
# test the server, then launch browser window to use the server 
# testing is a completely visual-inspection process; no validation of the results is done.
# test1 is performed by uploading json and downloading the scored response
# test2 is performed by launching a browser window so the tester can interactively verify that the website is functioning correctly.

# IMPLEMENTATION OF ROUTE SCORING
# NOTE: current implementation only good for one session at a time due to reliance on (meta) physical json files being dumped to disk. 
#
# preparation via setup.sh
# CAVEAT: First and foremost: This implementation is a hack done to get the demo up and running in a personal dev environment. These comment-strings are just the documentation to avoid confusion as this "requirements as hacky scripts" is converted into code.
# The preparation step enables pseudo-IPC by allowing server and modelgen to pass data without following good design practices (in order to rapidly set up an MVP).
# The preparation step creates links between required input/output json files such that server and model are "communicating" without being directly connected in any way.
# server dumps json for modelgen to consume or reads json generated by server
# modelgen consumes input json and generates output json
#
# route scoring via server.py and prepare_json.sh
# the server calls prepare_json.sh , which is just a wrapper to run the model generation code.
# this preserves some semblance of good design even though all of this is just a big ole hack.
# fortunately, this approach does mean that the server code already sees json generation as an abstraction, a deliberate design decision made so that this hacky "pseudo IPC" could be easily fixed in future without having to overcome strong bindings everywhere.

# WORKLOG CONTAINERISATION
# TODO: 1. convert this script to use vanilla Docker commands instead of current linux-based methodology
# TODO: 2. convert to use docker-compose


curdir=$(dirname $0)
cd $curdir

runall=1
if [[ $# -gt 0 ]]; then
  step=$1; shift;
  runall=0
fi

if [[ ${runall} -eq 1 ]]; then
  step="build";
fi

# image information
docker_user="yoinkbird"
app_name_server="cs_server"
image_tag_server="latest"
image_name_server="${docker_user}/${app_name_server}"
app_name_modelgen="cs_modelgen"
image_tag_modelgen="latest"
image_name_modelgen="${docker_user}/${app_name_modelgen}:${image_tag_modelgen}"

# TODO: build server image - provisional step to enable containerisation
# ...

# TODO: not working yet. pull - obtain modelgen artifact, provisional hacky methodology to locate either from registry or simply from localhost
if [[ 1 -eq 0 ]] && [ ${step} != "clean" ] && [ ${step} != "reset" ] ; then
  set +e
  docker pull ${image_name_modelgen} > /dev/null 2>&1
  if [[ $? -ne 0 ]]; then
    echo "WARN: could not pull ${image_name_modelgen}"
    echo "DEV: checking whether image exists locally"
  fi
  # DEV: redundant if already pulled, but useful if only developing locally
  docker inspect "${image_name_modelgen}" > /dev/null 2>&1
  if [[ $? -ne 0 ]]; then
    echo "FATAL: image ${image_name_modelgen} cannot be found"
    exit 1
  else
    echo "INFO: obtained image ${image_name_modelgen}"
  fi
  set -e
fi

modelgendir="modelgen";
modelgenbranch="containerize";
# check whether modelgen repo exists, clone as needed unless during the cleanup steps (clean and reset)
if [ ! -e "${modelgendir}/.git/config" ] && [ ${step} != "clean" ] && [ ${step} != "reset" ] ; then
  # get the host of the repo
  #+ process 'show origin' with perl to get the fetch/clone url,
  #+ then extract the github/username from that url
  github_host_repo_origin=$(git remote show origin | perl -nle 'm|Fetch URL: (.*)| && print $1' )
  github_host_user=$( dirname ${github_host_repo_origin} )
  github_url_modelgen="${github_host_user}/cyclesafe";
  # path exists but is not directory
  if [ -e ${modelgendir} ] && [ ! -d ${modelgendir} ] ; then
    echo "-E- : model generation repo likely not set up correctly";
    echo "-E- : ensure that directory [ $modelgendir ] contains the repo for generating the prediction model";
    exit;
    # path does not exist
  elif [ ! -e ${modelgendir} ] ; then
    # try to set up
    # simple: not cloned yet
    set -x
    git clone ${github_url_modelgen} ${modelgendir};
    # HARD_CODE
    cd ${modelgendir} && git checkout ${modelgenbranch} && cd -
    set +x 
    if [ $? -ne 0 ]; then
      echo "-E- : could not clone the repo";
    fi
  fi
fi

# remove the generated files and links
if [[ ${step} == "clean" ]] || [[ ${step} == "reset" ]]; then
  dbecho="echo"
  dbecho=""

  # hard-clean
  if [[ ${step} == "reset" ]]; then
    rm -rf ${modelgendir};
  fi

  # visually verify
  pwd
  git clean -xdn
  if [ -e ${modelgendir} ]; then
    cd ./${modelgendir}
    pwd
    git clean -xdn
    cd ..
  fi
fi

# build server image - provisional step to enable containerisation
if [[ "${step}" == "build" ]]; then
  docker build --tag ${image_name_server} .

  if [[ ${runall} -eq 1 ]]; then
    step="launch"
  fi
fi

set -u
urlAddress="http://localhost"
urlPort="8009"
jsonEndpoint="rest/score";
urlJsonServer="${urlAddress}:${urlPort}" # window.location.origin + '/rest/score'
urlJsonServerRest="${urlJsonServer}/${jsonEndpoint}" # window.location.origin + '/rest/score'
urlJsonServerRestPost="${urlJsonServerRest}""/""upload";
urlJsonServerRestGet="${urlJsonServerRest}""/""retrieve";
server_container_name="cs_server_${urlPort}"

if [[ ${step} == "launch" ]]; then


  # startup
  # if 'docker: Error response from daemon: driver failed programming external connectivity on endpoint cs_server_8009 (64c7...): Bind for 0.0.0.0:8009 failed: port is already allocated.', could just be from re-running
  docker run -d -p ${urlPort}:8009 --name "${server_container_name}" ${image_name_server}
  # was already useless # server_pid=$!
  echo $?
  # if server already running, the new PID just gets confusing
  #echo $! >> server_pid.txt

  # let it spin up
  sleep 1

  # how to kill the server
  echo "${server_container_name}" >> server_pid_lsof.txt

  if [[ ${runall} -eq 1 ]]; then
    step="verify"
  fi
fi

if [[ ${step} == "verify" ]]; then

  #-------------------------------------------------------------------------------- 
  # disable exit-on-error to manually verify based on output or error codes
  set +e
  echo "START VERIFY"

  #-------------------------------------------------------------------------------- 
  echo "VERIFY POST:"
  # mock client map-ui - upload json
  # test plan: send request, expect response to have input json returned; a hacky strategy, to be changed in https://github.com/YoinkBird/cyclesafe_server/issues/20, since this currently is an interface test being used to validate the implementation; there's no real need to verify anything but the HTTP return code.
  #+ src: https://stackoverflow.com/a/7173011
  echo "CMD: curl --fail-early -w \"http_code:[%{http_code}]\" --header \"Content-Type: application/json\" ${urlJsonServerRestPost} --data @${modelgendir}/t/route_json/gps_generic.json"
  resp="$(curl -s --fail-early --header "Content-Type: application/json" ${urlJsonServerRestPost} --data @${modelgendir}/t/route_json/gps_generic.json)"
  # jq-based verification:
  command -v jq > /dev/null
  rc=$?
  if [[ "${rc}" -eq 0 ]]; then
    # diff src: https://stackoverflow.com/a/37175540
    diff <(jq < ${modelgendir}/t/route_json/gps_generic.json) <(echo "${resp}" | jq) > /dev/null
    rc=$?
    if [[ "${rc}" -ne 0 ]]; then
      echo "ERROR: invalid response for POST: request json does not match response json"
      exit 1
    fi
  elif [[ "${resp}" == "" ]]; then
    echo "ERROR: invalid response for POST: response is empty (expected response json)"
    exit 1
  fi

  #-------------------------------------------------------------------------------- 
  # re-enable exit-on-error to rely solely on error codes
  set -e
  # HACK
  echo "HACK: VERIFY SUCCESFFUL ORCHESTRATION USING GET"
  # test plan: "orchestration testing" - check for known-errors resulting from incorrect configuration (i.e. if orchestration worked, this will pass).
  # DEPENDS ON a successful "POST"+"GET" to "flush out" issues with the hacky pseudo-IPC; this test relies on the previous test's POST to avoid potential side effects (no ROI in flushing that out...), but independently runs GET (next test with GET serves a different purpose)
  curl -s "${urlJsonServerRestGet}" > /dev/null 2>&1
  # Note: 'grep' will return zero if there is a match; '&& false' ensures that the successful grep $?==0 actually returns false and gets caught by 'set -e'. If there is no match, i.e. logs are clean, the unsuccessful grep $?==1 will be "suppressed" by the '&&' operation and not be treated as a failed command
  docker container logs "${server_container_name}" 2>&1 | (! grep "prepare_json.sh:\|python3: can't open file")
  # disable exit-on-error to manually verify based on output or error codes
  set +e

  #-------------------------------------------------------------------------------- 
  echo ""
  echo "VERIFY GET:"
  # mock client map-ui - retrieve json
 # test plan: Simply ensuring that the GET is successul; this is essentially verifying that the orchestration worked correctly. Note that, ideally, the live response could be compared against a static response; however, with ML models, it's non-trivial to simply compare the actual response against an expected response since the predictions can vary based on the dataset. To this end, some sort of fuzzy matching would be needed, or perhaps simply check the returned keys without values, etc. See https://github.com/YoinkBird/cyclesafe_server/issues/21
  # never mind the http_code; server returns 200 even for invalid queries as it doesn't have sane error handling
  echo "CMD: curl -s --fail-early ${urlJsonServerRestGet}"
  resp="$(curl -s --fail-early ${urlJsonServerRestGet})"
  rc=$?
  if [[ "${resp}" == "" ]]; then
    echo "ERROR: empty response for GET"
    exit 1
  fi

  #-------------------------------------------------------------------------------- 
  echo ""
  echo "VERIFY GET HTML:"
  # mock client map-ui - retrieve json
  resp="$(curl -s --fail-early -w "http_code:[%{http_code}]" --output /dev/null ${urlJsonServer}/directions.html)"
  if [[ "${resp}" != 'http_code:[200]' ]]; then
    echo "ERROR: empty response for GET HTML"
  fi

  #-------------------------------------------------------------------------------- 
  # re-enable exit-on-error to rely solely on error codes
  set -e
  echo ""
  echo "END VERIFY"

  # disable for now during non-GUI testing
  if [[ 0 -eq 1 ]] && [[ ${runall} -eq 1 ]]; then
    step="browser"
  fi
fi

if [[ ${step} == "browser" ]]; then
  # browser_and_args="chromium-browser --incognito"
  browser_and_args="firefox --private-window"
  #-------------------------------------------------------------------------------- 
  # mock client map-ui - view json in browser
  ${browser_and_args[@]} ${urlJsonServerRestGet}
  # how about some other things?
  # TODO: convert to host-specific call, i.e. http://localhost:8009/directions.html
  ${browser_and_args[@]} ${urlJsonServer}/directions.html # http://localhost:8009/directions_markers.html
fi

# stop the server. naming this step kill because it's using 'kill' instead of cleanly shutting down server
if [[ ${step} == "kill" ]]; then
  echo "stopping server via kill"
  killed=0
  for container_name in $(cat server_pid_lsof.txt); do
    set +e
    docker container kill "${container_name}"
    docker container rm "${container_name}"
    rc=$?
    if [[ $rc -eq 0 ]]; then
      killed=1
    fi
    set -e
  done
  if [[ $killed -eq 1 ]]; then
    set -x
    rm server_pid_lsof.txt
    set +x
  else
    echo "could not kill server"
  fi
fi

#-------------------------------------------------------------------------------- 
# show any running servers
#cat server_pid.txt
echo "remaining server ids: "
cat server_pid_lsof.txt || echo "... none found"
